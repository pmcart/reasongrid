generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// --- Organization ---

model Organization {
  id        String   @id @default(uuid())
  name      String
  slug      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  users      User[]
  employees  Employee[]
  importJobs ImportJob[]
  riskRuns   RiskRun[]
}

// --- Auth ---

enum UserRole {
  ADMIN
  HR_MANAGER
  MANAGER
  VIEWER
}

model User {
  id             String       @id @default(uuid())
  email          String       @unique
  passwordHash   String
  role           UserRole     @default(VIEWER)
  organizationId String
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt

  organization      Organization  @relation(fields: [organizationId], references: [id])
  importJobs        ImportJob[]
  ownedDecisions    PayDecision[] @relation("DecisionOwner")
  approvedDecisions PayDecision[] @relation("DecisionApprover")
}

// --- Employees ---

model Employee {
  id                String   @id @default(uuid())
  employeeId        String
  roleTitle         String
  jobFamily         String?
  level             String
  country           String
  location          String?
  currency          String
  baseSalary        Float
  bonusTarget       Float?
  ltiTarget         Float?
  hireDate          DateTime?
  employmentType    String?
  gender            String?
  performanceRating String?
  organizationId    String
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  organization Organization @relation(fields: [organizationId], references: [id])
  payDecisions PayDecision[]

  @@unique([organizationId, employeeId])
  @@index([organizationId])
  @@index([country, jobFamily, level])
}

// --- Pay Decisions ---

enum DecisionType {
  NEW_HIRE
  PROMOTION
  ADJUSTMENT
  ANNUAL_INCREASE
  OTHER
}

enum DecisionStatus {
  DRAFT
  FINALISED
}

model PayDecision {
  id                     String         @id @default(uuid())
  employeeId             String
  decisionType           DecisionType
  effectiveDate          DateTime
  payBeforeBase          Float
  payAfterBase           Float
  payBeforeBonus         Float?
  payAfterBonus          Float?
  payBeforeLti           Float?
  payAfterLti            Float?
  supportingContext       String
  evidenceReference      String?
  status                 DecisionStatus @default(DRAFT)
  accountableOwnerUserId String
  approverUserId         String
  finalisedAt            DateTime?
  createdAt              DateTime       @default(now())
  updatedAt              DateTime       @updatedAt

  employee   Employee @relation(fields: [employeeId], references: [id])
  owner      User     @relation("DecisionOwner", fields: [accountableOwnerUserId], references: [id])
  approver   User     @relation("DecisionApprover", fields: [approverUserId], references: [id])
  rationales PayDecisionRationale[]

  @@index([employeeId])
  @@index([status])
  @@index([effectiveDate])
}

enum Rationale {
  SENIORITY_TENURE
  RELEVANT_EXPERIENCE
  PERFORMANCE_HISTORY
  SCOPE_OF_ROLE
  MARKET_CONDITIONS
  GEOGRAPHIC_FACTORS
  INTERNAL_EQUITY_ALIGNMENT
  PROMOTION_HIGHER_RESPONSIBILITY
  TEMPORARY_ADJUSTMENT
}

model PayDecisionRationale {
  id             String      @id @default(uuid())
  payDecisionId  String
  rationale      Rationale

  payDecision PayDecision @relation(fields: [payDecisionId], references: [id], onDelete: Cascade)

  @@unique([payDecisionId, rationale])
}

// --- Imports ---

enum ImportJobStatus {
  PENDING_MAPPING
  PROCESSING
  COMPLETED
  FAILED
}

model ImportJob {
  id               String          @id @default(uuid())
  uploadedByUserId String
  organizationId   String
  status           ImportJobStatus @default(PENDING_MAPPING)
  filePath         String?
  createdCount     Int?
  updatedCount     Int?
  errorCount       Int?
  mappingJson      Json?
  errorReportPath  String?
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt

  uploadedBy   User         @relation(fields: [uploadedByUserId], references: [id])
  organization Organization @relation(fields: [organizationId], references: [id])
}

// --- Risk Analysis ---

enum RiskRunStatus {
  RUNNING
  COMPLETED
  FAILED
}

enum RiskState {
  WITHIN_EXPECTED_RANGE
  REQUIRES_REVIEW
  THRESHOLD_ALERT
}

model RiskRun {
  id             String        @id @default(uuid())
  triggeredBy    String
  organizationId String
  startedAt      DateTime      @default(now())
  finishedAt     DateTime?
  status         RiskRunStatus @default(RUNNING)

  organization Organization    @relation(fields: [organizationId], references: [id])
  groups       RiskGroupResult[]
}

model RiskGroupResult {
  id                String    @id @default(uuid())
  riskRunId         String
  country           String
  jobFamily         String?
  level             String
  roleTitleFallback String?
  groupKey          String
  womenCount        Int
  menCount          Int
  gapPct            Float
  riskState         RiskState
  notes             String?
  computedAt        DateTime  @default(now())

  riskRun RiskRun @relation(fields: [riskRunId], references: [id], onDelete: Cascade)

  @@index([groupKey])
  @@index([riskState])
  @@index([computedAt])
}
